import { CoreMessage, streamText, tool, generateText } from 'ai'; // Removed ToolResult
import { google } from '@ai-sdk/google';
import { anthropic } from '@ai-sdk/anthropic';
import { z } from 'zod';
// Import the robust HTML utility function
// Removed html-utils import

// Define a simpler, single-page base HTML structure
const genericBaseHtml = `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>AI Generated Page</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@1.0.2/css/bulma.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.min.js"></script>
  <style>
    body { background-color: #ffffff; color: #333333; }
    .section { background-color: #f5f5f5; border-radius: 6px; margin-bottom: 1.5rem; }
    .title, .subtitle { color: #333333; }
    .box { background-color: #ffffff; color: #333333; border: 1px solid #e0e0e0; }
    .footer { background-color: #f5f5f5; color: #666666; }
    #error-message-container { color: #ff3860; margin-top: 1rem; text-align: center; }
  </style>
</head>
<body>
  <!-- Header Section -->
  <section class="hero" id="header-section">
    <div class="hero-body">
      <div class="container">
        <h1 class="title" id="main-title">AI Generated Page</h1>
        <h2 class="subtitle" id="main-subtitle">Content being generated...</h2>
      </div>
    </div>
  </section>

  <!-- Main Content Area -->
  <main class="container section" id="main-content-area">
    <!-- Content will be dynamically inserted here by the AI -->
    <p>Loading content...</p>
  </main>

  <!-- Error Message Area -->
  <div class="container" id="error-message-container">
    <!-- Errors will be displayed here -->
  </div>

  <!-- Footer -->
  <footer class="footer" id="footer-section">
    <div class="content has-text-centered">
      <p id="footer-content">Generated by AI</p>
    </div>
  </footer>
</body>
</html>`;


// --- Sub-tool Schemas Removed ---

// --- Main Website Generator Tool Schema ---
const websiteGeneratorSchema = z.object({
  currentHtml: z.string().nullable().optional().describe('The current HTML content of the website, if it exists. Can be null if starting fresh.'),
  updateInstructions: z.string().describe('Specific instructions based on the latest user input for how to update the website (e.g., "Update the overview section with this summary", "Change the main title to \'Project Dashboard\'").'),
});

// --- System Prompt for Full HTML Generation ---
const websiteGenerationSystemPrompt = `You are an AI assistant responsible for generating or updating a complete HTML document based on user instructions.
Analyze the 'Update Instructions' and the 'Current HTML' (if provided).
Generate the *complete, updated HTML content* that incorporates the requested changes.
Output ONLY the raw, complete, updated HTML string. Do not include any explanations, markdown formatting, or anything other than the HTML code itself.

**IMPORTANT RESTRICTION:** Do NOT invent dynamic data such as cryptocurrency prices, market statistics, news headlines, or specific numerical values unless explicitly provided in the instructions. Use Public API if needed. Use clear placeholders like "[Current Price]", "[Market Cap]", "[Latest News Headline 1]", or descriptive text like "Chart loading..." where dynamic data should appear. Focus on creating the correct HTML structure and layout for the data, not the data itself. Also, do NOT use local image paths (e.g., '/img/...') or invent image URLs. Only use external image URLs (like from Unsplash) if they are directly relevant and you are certain they exist, otherwise omit images or use placeholders. Furthermore, when adding JavaScript within \`<script>\` tags (e.g., for chart initialization), do NOT use \`import\` statements; assume libraries like Chart.js are globally available via CDN and access them directly (e.g., \`new Chart(...)\`).`;


export async function POST(req: Request) {
  console.log("Entering POST /api/chat");
  try {
    const { messages }: { messages: CoreMessage[] } = await req.json();

    // Find the last tool_result for 'websiteGenerator' to get the latest HTML
    let latestHtml: string | null = null;
    for (let i = messages.length - 1; i >= 0; i--) {
        const msg = messages[i];
        // console.log(`[HTML Finder] Checking message index ${i}, role: ${msg.role}`); // Optional: Log every message checked
        if (msg.role === 'tool' && msg.content && Array.isArray(msg.content)) {
             console.log(`[HTML Finder] Found tool message at index ${i}. Content:`, JSON.stringify(msg.content));
             const websiteGenResult = msg.content.find(item => item.toolName === 'websiteGenerator');
             console.log(`[HTML Finder] Result of find for 'websiteGenerator':`, websiteGenResult ? JSON.stringify(websiteGenResult) : 'Not found');
             if (websiteGenResult && typeof websiteGenResult.result === 'object' && websiteGenResult.result !== null && 'htmlContent' in websiteGenResult.result) {
                 latestHtml = (websiteGenResult.result as { htmlContent: string }).htmlContent;
                 console.log(`[HTML Finder] Successfully extracted htmlContent from tool result at index ${i}.`);
                 break;
             } else if (websiteGenResult) {
                 console.log(`[HTML Finder] Found websiteGenResult at index ${i}, but 'htmlContent' property is missing or invalid in result object.`);
             }
        }
    }
     if (!latestHtml) {
        console.log("No previous HTML state found, will use generic base or initialize.");
    }


    const result = streamText({
      model: anthropic('claude-3-7-sonnet-20250219'), // Model for main chat interaction
      system: `You are a helpful AI assistant. You can use tools to perform specific tasks, like generating or updating website content based on the conversation. When asked to create or modify a website, first assess if the request is clear and detailed enough. If the request is ambiguous or lacks necessary details, ask clarifying questions before proceeding or using the 'websiteGenerator' tool. Once the requirements are clear, use the 'websiteGenerator' tool to perform the task. Explain the changes you are making via the tool. Do not output raw HTML in your main response. IMPORTANT: When using the websiteGenerator, ensure the AI does not invent dynamic data (like prices, stats, news). It should use clear placeholders (e.g., [Current Price], [Market Cap]) or descriptive text where real data would go.`,
      messages,
      tools: {
        websiteGenerator: tool({
          description: 'Generates or updates the website HTML based on user input and conversation context. Use this tool for all website modifications.',
          parameters: websiteGeneratorSchema,
          execute: async ({ currentHtml, updateInstructions }) => {
            console.log(`[websiteGenerator] Entering execute`);
            console.log(`[websiteGenerator] Received updateInstructions: ${updateInstructions}`);
            // Use 'let' so it can be reassigned by the sub-tool execute functions
            let workingHtml = currentHtml ?? latestHtml ?? genericBaseHtml;
            console.log(`[websiteGenerator] Starting HTML size: ${workingHtml.length} chars`);

            try {
                console.log('[websiteGenerator] Initiating direct AI call for full HTML generation...');

                // Directly call generateText, expecting the full HTML as output
                const { text: generatedHtml } = await generateText({
                    model: anthropic('claude-3-7-sonnet-20250219'), // Model specifically for HTML generation task
                    system: websiteGenerationSystemPrompt, // Use the specific system prompt for this task
                    prompt: `Current HTML:
\`\`\`html
${workingHtml}
\`\`\`

Update Instructions: ${updateInstructions}`,
                    // No tools needed here, expecting raw HTML output
                });

                console.log('[websiteGenerator] Direct AI call finished.');

                if (!generatedHtml || typeof generatedHtml !== 'string' || generatedHtml.trim() === '') {
                    console.warn('[websiteGenerator] AI did not return valid HTML content. Returning previous HTML.');
                     // Attempt to clean up potential markdown fences if AI mistakenly added them
                    const cleanedHtml = generatedHtml?.replace(/^```html\s*|\s*```$/g, '').trim();
                    if (cleanedHtml) {
                         console.log(`[websiteGenerator] Cleaned potential markdown. Final size: ${cleanedHtml.length} chars.`);
                         return { htmlContent: cleanedHtml };
                    }
                    // Return original HTML if generation failed or was empty
                    return {
                        htmlContent: workingHtml,
                        error: 'AI failed to generate valid HTML content.'
                    };
                }

                console.log(`[websiteGenerator] Generated HTML size: ${generatedHtml.length} chars.`);
                console.log(`[websiteGenerator] execute finished. Returning generated HTML.`);
                // The result expected by the client
                return {
                  htmlContent: generatedHtml.trim(),
                };
            } catch (error) {
                 console.error('[websiteGenerator] Error during direct AI call:', error);
                 // Return the HTML as it was before the failed call
                 return {
                     htmlContent: workingHtml,
                     error: `Failed to generate HTML: ${error instanceof Error ? error.message : String(error)}`
                 };
            }
          },
        }),
      },
      maxSteps: 5, // Allow the main AI to call websiteGenerator multiple times if needed
      onError: (error) => {
        console.error("Error during main streamText:", error);
      },
    });

    return result.toDataStreamResponse();

  } catch (error) {
    console.error("ERROR in POST /api/chat:", error);
    if (error instanceof Error) {
       return new Response(JSON.stringify({ error: error.message }), { status: 500 });
    } else {
       return new Response(JSON.stringify({ error: 'An unknown error occurred' }), { status: 500 });
    }
  }
}

// Placeholder utils removed, now importing from ./html-utils.ts